title: Lambda vs Function Comparison in Weave

# Source code examples
function_source: {
  shape: page
  label: "Named Function\nfn add(a, b) {\n  a + b\n}"
}

lambda_source: {
  shape: page
  label: "Lambda Expression\nadd = ^(a, b) {\n  a + b\n}"
}

# Compilation paths
function_path: {
  label: "Function Compilation Path"
  
  fn_token: {
    shape: rectangle
    label: "FN Token"
  }
  
  fn_statement: {
    shape: rectangle  
    label: "function_statement()\nBind to identifier"
  }
  
  fn_compile: {
    shape: rectangle
    label: "function()\nCompile body"
  }
}

lambda_path: {
  label: "Lambda Compilation Path"
  
  caret_token: {
    shape: rectangle
    label: "Caret Token"
  }
  
  lambda_expr: {
    shape: rectangle
    label: "lambda()\nExpression context"
  }
  
  lambda_compile: {
    shape: rectangle
    label: "lambda_function()\nCompile body"
  }
}

# Shared compilation components
shared: {
  label: "Shared Compilation Infrastructure"
  
  params: {
    shape: hexagon
    label: "function_params()\nParameter parsing"
  }
  
  block: {
    shape: hexagon
    label: "block()\nBody compilation"
  }
  
  scope: {
    shape: hexagon
    label: "Scope Management\nbegin_scope() / end_scope()"
  }
  
  upvalues: {
    shape: hexagon
    label: "Upvalue Resolution\nVariable capture"
  }
}

# Runtime representation
runtime: {
  label: "Runtime Representation"
  
  weave_fn: {
    shape: cylinder
    label: "WeaveFn\n- chunk: Chunk\n- name: String\n- arity: usize\n- upvalue_count: u8"
  }
  
  closure: {
    shape: cylinder
    label: "FnClosure\n- func: Rc<WeaveFn>\n- upvalues: Vec<WeaveUpvalue>"
  }
}

# Key differences table
differences: {
  label: "Key Differences"
  
  context: {
    shape: rectangle
    label: "Context\nFunction: Statement\nLambda: Expression"
  }
  
  binding: {
    shape: rectangle  
    label: "Name Binding\nFunction: Creates variable\nLambda: Evaluates to value"
  }
  
  usage: {
    shape: rectangle
    label: "Usage\nFunction: fn name() {}\nLambda: var = ^() {}"
  }
  
  debug_name: {
    shape: rectangle
    label: "Debug Name\nFunction: actual name\nLambda: \"<lambda>\""
  }
}

# Performance comparison
performance: {
  label: "Performance Characteristics"
  
  compile_time: {
    shape: rectangle
    label: "Compile Time\nFunction: ~1.2μs\nLambda: ~1.3μs\n(+100ns overhead)"
  }
  
  runtime_perf: {
    shape: rectangle
    label: "Runtime Performance\nFunction: 150ns/call\nLambda: 150ns/call\n(Identical)"
  }
  
  memory: {
    shape: rectangle
    label: "Memory Usage\nFunction: 64 bytes base\nLambda: 64 bytes base\n(Same FnClosure)"
  }
}

# Flow connections
function_source -> function_path.fn_token
function_path.fn_token -> function_path.fn_statement
function_path.fn_statement -> function_path.fn_compile

lambda_source -> lambda_path.caret_token  
lambda_path.caret_token -> lambda_path.lambda_expr
lambda_path.lambda_expr -> lambda_path.lambda_compile

function_path.fn_compile -> shared.params
lambda_path.lambda_compile -> shared.params

shared.params -> shared.block
shared.block -> shared.scope
shared.scope -> shared.upvalues

shared.upvalues -> runtime.weave_fn
runtime.weave_fn -> runtime.closure

# Style the diagram
function_source.style.fill: "#e3f2fd"
lambda_source.style.fill: "#f3e5f5"

function_path.*.style.fill: "#e8f5e8"
lambda_path.*.style.fill: "#fff3e0"

shared.*.style.fill: "#f5f5f5"
runtime.*.style.fill: "#fce4ec"

differences.*.style.fill: "#fff8e1"
performance.*.style.fill: "#f1f8e9"

# Add comparison arrows
function_path.fn_compile -> lambda_path.lambda_compile: {
  label: "Different entry points,\nsame compilation logic"
  style.stroke-dash: 5
}

runtime.weave_fn -> runtime.closure: {
  label: "Identical runtime\nrepresentation"
  style.stroke-width: 3
}