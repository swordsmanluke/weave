title: Lambda Compilation Flow in Weave

# Source code input
source: {
  shape: page
  label: "Source Code\nadd = ^(a, b) { a + b }"
}

# Lexical Analysis Phase
scanner: {
  shape: rectangle
  label: "Scanner\n(scanner.rs:111)"
}

tokens: {
  shape: cylinder
  label: "Tokens\n[Identifier, Equal, Caret,\nLeftParen, Identifier, Comma,\nIdentifier, RightParen,\nLeftBrace, ..., RightBrace]"
}

# Parsing Phase
parser: {
  shape: rectangle
  label: "Parser\n(parse_rule.rs:53)"
}

parse_rule: {
  shape: diamond
  label: "Parse Rule\nCaret â†’ prefix(lambda)"
}

# Compilation Phase
compiler: {
  shape: rectangle
  label: "Compiler\n(compiler.rs:588)"
}

lambda_steps: {
  step1: {
    shape: rectangle
    label: "1. Enter Scope\nscope.enter_scope()"
  }
  
  step2: {
    shape: rectangle
    label: "2. Create Function Compiler\nnew_func_compiler(\"<lambda>\")"
  }
  
  step3: {
    shape: rectangle
    label: "3. Compile Lambda Function\nlambda_function()"
  }
  
  step4: {
    shape: rectangle
    label: "4. Emit Closure\nemit_closure()"
  }
  
  step5: {
    shape: rectangle
    label: "5. Exit Scope\nscope.exit_scope()"
  }
}

# Lambda Function Compilation Details
lambda_function: {
  shape: rectangle
  label: "lambda_function()\n(compiler.rs:305)"
}

function_steps: {
  param_parse: {
    shape: rectangle
    label: "Parse Parameters\nfunction_params()"
  }
  
  body_parse: {
    shape: rectangle
    label: "Parse Body\nblock()"
  }
  
  scope_mgmt: {
    shape: rectangle
    label: "Scope Management\nbegin_scope()"
  }
}

# Upvalue Resolution
upvalue_resolution: {
  shape: rectangle
  label: "Upvalue Resolution\n(scope.rs)"
}

# Bytecode Generation
bytecode_gen: {
  shape: rectangle
  label: "Bytecode Generation\nemit_closure()"
}

bytecode: {
  shape: cylinder
  label: "Generated Bytecode\nOp::Closure [constant_idx]\n[upvalue_data...]"
}

# Closure Object Creation
closure_obj: {
  shape: hexagon
  label: "FnClosure Object\n- func: WeaveFn\n- upvalues: Vec<WeaveUpvalue>"
}

# VM Execution
vm: {
  shape: rectangle
  label: "VM Execution\n(vm.rs:356)"
}

runtime_result: {
  shape: page
  label: "Runtime Result\nCallable closure object\nready for execution"
}

# Flow connections
source -> scanner: "Character stream"
scanner -> tokens: "Tokenize"
tokens -> parser: "Token stream"
parser -> parse_rule: "Caret token"
parse_rule -> compiler: "lambda() method"

compiler -> lambda_steps.step1
lambda_steps.step1 -> lambda_steps.step2
lambda_steps.step2 -> lambda_steps.step3
lambda_steps.step3 -> lambda_steps.step4
lambda_steps.step4 -> lambda_steps.step5

lambda_steps.step3 -> lambda_function: "Call"
lambda_function -> function_steps.scope_mgmt
function_steps.scope_mgmt -> function_steps.param_parse
function_steps.param_parse -> function_steps.body_parse

function_steps.body_parse -> upvalue_resolution: "Variable references"
upvalue_resolution -> bytecode_gen: "Upvalue data"

lambda_steps.step4 -> bytecode_gen
bytecode_gen -> bytecode: "Generate"
bytecode -> closure_obj: "Create"
closure_obj -> vm: "Execute"
vm -> runtime_result: "Result"

# Style the diagram
*.style.font-size: 12

source.style.fill: "#e1f5fe"
scanner.style.fill: "#f3e5f5"
parser.style.fill: "#f3e5f5"
compiler.style.fill: "#fff3e0"
lambda_function.style.fill: "#fff3e0"
bytecode_gen.style.fill: "#e8f5e8"
vm.style.fill: "#fce4ec"

tokens.style.fill: "#f5f5f5"
bytecode.style.fill: "#f5f5f5"
closure_obj.style.fill: "#f0f0f0"
runtime_result.style.fill: "#e1f5fe"