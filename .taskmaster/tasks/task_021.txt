# Task ID: 21
# Title: Bytecode and Memory Optimizations with Shared References and Arena Allocation
# Status: pending
# Dependencies: 19, 18
# Priority: low
# Description: Implement shared bytecode references instead of cloning for CallFrames, replace HashMap globals with compile-time array indexing, and implement arena allocation for temporary objects to achieve 10-15% performance improvement through better cache locality.
# Details:
Implement comprehensive bytecode and memory optimizations: 1) Replace CallFrame bytecode cloning with shared references using Rc<Chunk> or Arc<Chunk> to eliminate duplicate bytecode storage across multiple frames. Modify CallFrame structure to hold reference instead of owned Chunk. 2) Replace HashMap-based global variable storage with compile-time constant array indexing. Generate compile-time global index table mapping variable names to array indices, replace runtime HashMap lookups with direct array access using pre-computed indices. 3) Implement arena allocation system for temporary objects during VM execution. Create StackArena that pre-allocates memory blocks for temporary WeaveType instances, use bump pointer allocation for O(1) temporary object creation, batch deallocate entire arena when leaving scope. 4) Optimize memory layout for better cache locality - group frequently accessed VM fields together, align data structures to cache line boundaries, minimize pointer indirection in hot paths. 5) Profile memory access patterns and optimize data structure layout to minimize cache misses during instruction execution.

# Test Strategy:
Performance validation and memory optimization verification: 1) Benchmark current implementation vs optimized version using fibonacci(35), nested function calls with 10 levels, and global variable access patterns to measure 10-15% performance improvement. 2) Use memory profiler (valgrind/heaptrack) to verify elimination of bytecode duplication and reduced allocation overhead from arena system. 3) Measure cache performance using perf stat -e cache-misses,cache-references to validate improved cache locality. 4) Create stress tests with hundreds of concurrent CallFrames to verify shared bytecode references work correctly without memory corruption. 5) Test global variable access performance with 100+ globals to verify array indexing outperforms HashMap lookups. 6) Validate correctness with existing closure and function call test suites to ensure optimizations don't break semantics.
