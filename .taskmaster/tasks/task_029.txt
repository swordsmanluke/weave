# Task ID: 29
# Title: Investigate and Fix Upvalue System Bugs
# Status: pending
# Dependencies: 1, 2, 3, 4, 5, 11, 12, 13, 14, 17
# Priority: high
# Description: Perform comprehensive root cause analysis and implement systematic fixes for critical upvalue system bugs causing closure test failures, focusing on upvalue lifecycle management, invalid stack indices, and 'Only functions can be called' errors in the existing arena-based upvalue architecture.
# Details:
Given that the upvalue architecture with arena-backed heap storage is correctly implemented (Open upvalues reference stack, Closed upvalues use Rc<RefCell<NanBoxedValue>>), focus investigation on operational issues: 1) Upvalue closure timing: Determine when and why upvalues aren't being closed at appropriate times, particularly during function returns and scope exits. Analyze the transition from open to closed state and identify missing closure triggers. 2) Stack index invalidation: Investigate why stack indices become invalid before upvalue closure occurs. Trace the exact sequence where stack modifications happen before upvalue migration to heap storage. 3) Expression evaluation interference: Examine how expression-based semantics disrupt upvalue lifecycle management, particularly intermediate values affecting upvalue references. 4) Function call errors: Debug why closures report 'Only functions can be called' - investigate WeaveType checking and function call resolution in the VM. Focus on vm.rs upvalue access patterns, closure timing in pop_frame(), and expression evaluation stack management.

# Test Strategy:
Create targeted test suite focusing on operational failures: 1) Upvalue closure timing tests: Test upvalue state transitions during various scope exit scenarios (function returns, block exits, early returns). Verify upvalues close at the correct moments. 2) Stack index validity tests: Test scenarios where stack modifications occur before upvalue closure, ensuring indices remain valid until migration. 3) Function call resolution tests: Create tests specifically for 'Only functions can be called' errors - verify closure objects maintain proper function type identification. 4) Expression interference tests: Test upvalue access within complex expressions to identify how expression evaluation affects upvalue lifecycle. 5) Existing closure test analysis: Run test_closures_basic through test_closures_complex with detailed logging to identify exact failure points.

# Subtasks:
## 1. Analyze Upvalue Closure Timing Issues [done]
### Dependencies: None
### Description: Investigate when and why upvalues aren't being closed at appropriate times, focusing on the transition from open to closed state
### Details:
Focus on upvalue lifecycle management in the existing architecture: 1) Instrument vm.rs pop_frame() and other scope exit points to trace upvalue closure attempts. 2) Analyze CallFrame destruction and its relationship to upvalue closure. 3) Map all code paths where upvalues should transition from open to closed state. 4) Identify scenarios where scope exit occurs but upvalues remain open with invalid stack references. 5) Examine upvalue collection and closure trigger logic. 6) Document the complete upvalue closure workflow and identify missing triggers.
<info added on 2025-07-30T15:09:32.825Z>
Discovery: 1) The CloseUpvalues instruction is never emitted by the compiler because it was removed from the block() function, meaning upvalues are only closed during RETURN opcodes. This creates a critical bug where upvalues remain open with invalid stack references when their scope ends but the function hasn't returned. 2) The closure test failure is actually a compilation error, not a runtime error, indicating the issue may be in bytecode generation rather than VM execution. The disassembly shows GetUpvalue, SetUpvalue, and Closure instructions are being generated. 3) While the arena-based heap storage is working correctly, the timing of upvalue closure is fundamentally broken. Next steps required: investigate the compilation error details, determine correct placement for CloseUpvalues instruction emission in the compiler, and analyze how expression-based language semantics should handle upvalue closure differently from statement-based languages.
</info added on 2025-07-30T15:09:32.825Z>
<info added on 2025-07-30T15:14:28.144Z>
<info added on 2025-07-30T15:11:45.123Z>
MAJOR BREAKTHROUGH: Root cause has shifted from upvalue closure timing to VM call mechanism. The closure test now runs successfully through compilation and closure creation, but fails at runtime with 'Only functions can be called' error. Investigation reveals: 1) CloseUpvalues instruction absence confirmed as expected behavior since it was intentionally removed from block() function. 2) Upvalues are correctly closed only during RETURN opcodes, which is working as designed. 3) Closure bytecode generation is functioning properly - Closure instructions with upvalues are being emitted correctly. 4) NEW CRITICAL FINDING: The VM's call mechanism is not recognizing WeaveUpvalue-containing closures as valid callable functions. This indicates the issue is in the runtime function type checking logic, not in upvalue lifecycle management. Next investigation must focus on vm.rs call mechanism to determine why closures with upvalues fail the callable function validation.
</info added on 2025-07-30T15:11:45.123Z>
</info added on 2025-07-30T15:14:28.144Z>
<info added on 2025-07-30T15:30:21.591Z>
Debug logging with vm-debug feature flag implemented to investigate closure call type mismatch without runtime overhead. Key findings: 1) Simple closures without upvalues execute successfully through the entire call mechanism. 2) Closures containing upvalues fail specifically at call time with 'Only functions can be called' error, indicating a type checking problem in the VM's call validation. 3) The issue is isolated to the callable function validation logic - closure creation works correctly, but the runtime doesn't recognize upvalue-containing closures as valid callable types. This confirms the root cause is in vm.rs call mechanism rather than upvalue lifecycle or bytecode generation.
</info added on 2025-07-30T15:30:21.591Z>
<info added on 2025-07-30T15:33:05.924Z>
CRITICAL ROOT CAUSE IDENTIFIED: Stack indexing bug confirmed in call mechanism. Closures are created correctly on the stack (verified as valid ClosureHandle pointers), but during function call execution, the VM retrieves wrong stack position and gets Number(0) instead of the expected ClosureHandle. This is a stack positioning/indexing issue in vm.rs call logic, not a closure creation or type checking problem. The bug causes 'Only functions can be called' error because Number(0) fails callable validation. Investigation must now focus on call stack indexing arithmetic and stack pointer management during closure invocation.
</info added on 2025-07-30T15:33:05.924Z>

## 2. Debug Stack Index Invalidation Sequence [done]
### Dependencies: 29.1
### Description: Trace the exact sequence where stack modifications happen before upvalue closure, causing invalid indices
### Details:
Investigate the timing of stack operations vs upvalue closure: 1) Add detailed logging to all stack modification operations (POP, function returns, expression evaluation). 2) Trace upvalue access attempts and correlate with stack state. 3) Identify the exact sequence where stack indices become stale before upvalue migration. 4) Analyze vm.rs Op::GetUpvalue/SetUpvalue for index validation and error handling. 5) Map stack frame lifecycle vs upvalue lifecycle timing conflicts. 6) Document specific operations that invalidate upvalue indices before closure occurs.
<info added on 2025-07-30T15:37:26.037Z>
CRITICAL BUG IDENTIFIED: Stack corruption occurs between GET_LOCAL and CALL operations. The closure is correctly stored in local variable slot 4 and retrieved as Pointer(ClosureHandle, 0x300000002) via GET_LOCAL, but mysteriously transforms to Number(0) on the stack before CALL executes. Stack state changes from [ClosureHandle, ClosureHandle, Number(0), Number(0), String, String] to [ClosureHandle, ClosureHandle, Number(0), Number(0), String, Number(0)] immediately before the call operation. This indicates a stack element overwrite bug occurring after successful local variable retrieval but before function invocation. The corruption happens to the specific stack position containing the closure, suggesting either: 1) Incorrect stack pointer manipulation between operations, 2) Memory corruption in the stack storage, or 3) Intermediate operations inadvertently overwriting the stack slot. This explains why closures appear valid during storage/retrieval but fail at call time with "Only functions can be called" errors.
</info added on 2025-07-30T15:37:26.037Z>
<info added on 2025-07-30T16:02:58.019Z>
ROOT CAUSE CONFIRMED: POP logic in while loops is corrupting stack for upvalue closures. The issue is in while_statement() line 417: self.emit_basic_opcode(Op::POP) combined with block() POPs. Our closure test has expressions that create upvalue references to local stack slots, but POPs are disrupting the expected stack layout. Simple closures work because they have no upvalue stack dependencies. The stack corruption happens when POP operations invalidate upvalue stack references after closure creation but before closure call. This explains the mysterious transformation from ClosureHandle to Number(0) - the POP operations are clearing stack slots that upvalue closures still reference, breaking the closure's ability to access its captured variables at call time.
</info added on 2025-07-30T16:02:58.019Z>

## 3. Investigate 'Only Functions Can Be Called' Errors [done]
### Dependencies: None
### Description: Debug why closures report function call errors, examining WeaveType checking and function call resolution
### Details:
Focus on closure function call resolution: 1) Analyze WeaveType enum handling for closure values in function call operations. 2) Examine vm.rs function call dispatching and type checking for closures. 3) Investigate if upvalue corruption affects closure function object integrity. 4) Review closure creation and storage to ensure proper WeaveType assignment. 5) Check if invalid upvalue references cause closure objects to become corrupted. 6) Trace the complete path from closure creation to function call attempt.

## 4. Analyze Expression Evaluation Impact on Upvalue Lifecycle [done]
### Dependencies: 29.1, 29.2
### Description: Examine how expression-based semantics interfere with upvalue lifecycle management and stack state
### Details:
Investigate expression evaluation interference: 1) Study how intermediate expression values affect stack frame structure during upvalue access. 2) Analyze compiler.rs expression compilation and its impact on upvalue indexing. 3) Examine vm.rs expression evaluation stack management and upvalue reference validity. 4) Identify expression patterns that disrupt upvalue closure timing. 5) Review how Weave's expression-everywhere design affects traditional closure stack assumptions. 6) Map expression evaluation phases vs upvalue lifecycle events.

## 5. Implement Operational Fixes and Validate Solution [done]
### Dependencies: 29.1, 29.2, 29.3, 29.4
### Description: Apply targeted fixes to upvalue closure timing, stack index validation, and function call resolution based on investigation findings
### Details:
Implement fixes for identified operational issues: 1) Fix upvalue closure timing by adding proper closure triggers at all scope exit points. 2) Implement additional stack index validation before upvalue access to prevent out-of-bounds errors. 3) Fix closure function call resolution issues identified in type checking. 4) Add defensive programming measures for expression evaluation vs upvalue access conflicts. 5) Implement comprehensive error handling for upvalue operations. 6) Add runtime diagnostics for upvalue state monitoring. 7) Ensure fixes maintain the existing arena-based architecture without architectural changes.
<info added on 2025-07-30T16:13:21.998Z>
Implemented fix for upvalue closure timing in block() function by adding CloseUpvalues emission before POP operations. The fix ensures upvalues are properly migrated to heap storage before any stack modifications that could invalidate stack references. Successfully resolved compilation issue with scope field access by switching to locals_at() method instead of direct field access. This addresses the first critical operational issue - upvalue closure timing at scope exit points.
</info added on 2025-07-30T16:13:21.998Z>
<info added on 2025-07-30T16:17:28.981Z>
PARTIAL SUCCESS documented: CloseUpvalues emission successfully implemented and working correctly. Upvalue closure timing has been fixed with proper migration to heap storage before POP operations. Disassembly issues resolved. However, investigation reveals that while the upvalue-specific timing issue is resolved, a broader stack management problem persists in a different system component. During second function call, local variable retrieval incorrectly returns Number(0) instead of the expected closure handle, indicating stack corruption outside the upvalue system. This suggests the fix addresses the upvalue lifecycle component but exposes an underlying stack management issue that requires separate investigation and resolution.
</info added on 2025-07-30T16:17:28.981Z>

## 6. Run Unit Tests and Investigate Remaining Test Failures [pending]
### Dependencies: None
### Description: Execute cargo test to identify any remaining test failures after the upvalue closure timing fix, analyze root causes of broken tests, and implement targeted fixes to ensure all closure and upvalue tests pass
### Details:


