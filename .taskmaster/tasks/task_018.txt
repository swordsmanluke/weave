# Task ID: 18
# Title: Implement NaN-boxing Value Representation for WeaveType
# Status: pending
# Dependencies: None
# Priority: high
# Description: Replace the current 32-byte WeaveType enum with 64-bit NaN-boxing to store numbers, booleans, and null directly in a single 64-bit value, eliminating boxing overhead and reducing memory traffic by 4x.
# Details:
Implement NaN-boxing technique using IEEE 754 double-precision floating-point representation to encode multiple value types in a single 64-bit value. Design: Use quiet NaN space (0x7FF8000000000000 to 0x7FFFFFFFFFFFFFFF) for non-numeric values. Encoding scheme: 1) Numbers: Store directly as f64 values (canonical NaN becomes 0x7FF8000000000001). 2) Boolean true: 0x7FF8000000000003, false: 0x7FF8000000000002. 3) Null: 0x7FF8000000000004. 4) Pointers (strings, functions, closures): Use 48-bit payload space for pointer storage with tag bits for type discrimination. Implementation steps: 1) Create new NanBoxedValue type wrapping u64 with methods for encoding/decoding each type. 2) Replace WeaveType enum with NanBoxedValue throughout VM stack, locals, and upvalues. 3) Update all VM opcodes to work with NaN-boxed values directly. 4) Implement fast-path arithmetic operations that operate on raw f64 values without unpacking. 5) Add debug assertions to verify pointer alignment and tag validity. 6) Update garbage collection to properly trace through NaN-boxed pointers. Critical optimizations: Use inline assembly or intrinsics for fast type checking (test high 16 bits), implement branchless arithmetic operations, ensure stack operations use memcpy for bulk moves.

# Test Strategy:
Comprehensive testing strategy: 1) Unit tests for NanBoxedValue encoding/decoding of all value types, verifying bit patterns match specification. 2) Property-based tests ensuring round-trip encoding/decoding preserves values exactly. 3) Performance benchmarks comparing current WeaveType operations vs NaN-boxed operations, targeting 5-10x improvement for numeric operations. 4) Stress tests with edge cases: special float values (infinity, -0.0, denormals), maximum pointer values, rapid type transitions. 5) Integration tests running all existing Weave test programs to ensure semantic preservation. 6) Memory layout tests verifying 4x reduction in stack memory usage. 7) Garbage collection tests ensuring pointer tracing works correctly through NaN-boxed values. 8) Cross-platform tests verifying consistent behavior on different architectures (x86_64, ARM64).

# Subtasks:
## 1. Design and Implement NanBoxedValue Core Type [done]
### Dependencies: None
### Description: Create the foundational NanBoxedValue type that wraps u64 and implements the NaN-boxing encoding scheme for all Weave value types
### Details:
Implement NanBoxedValue struct wrapping u64 with methods for encoding/decoding each type according to the specification: Numbers stored directly as f64 (canonical NaN → 0x7FF8000000000001), Boolean true: 0x7FF8000000000003, false: 0x7FF8000000000002, Null: 0x7FF8000000000004. Implement pointer encoding using 48-bit payload space with tag bits for type discrimination. Add inline methods for fast type checking using bit manipulation, implement From/Into traits for seamless conversion, and add debug assertions for pointer alignment and tag validity. Include comprehensive unit tests verifying bit patterns match specification exactly.
<info added on 2025-07-28T20:34:41.223Z>
COMPLETED: Implemented NanBoxedValue core type with full functionality:

- Complete 64-bit value representation using IEEE 754 NaN-boxing
- Efficient encoding: numbers (direct f64), booleans (0x7FF8000000000003/2), null (0x7FF8000000000004), pointers (48-bit payload with tags)
- Fast type checking using bit manipulation instead of enum pattern matching
- Comprehensive unit tests covering all value types and edge cases including signaling NaN
- Module integration complete - available as pub use nan_boxed_value::{NanBoxedValue, PointerTag}
- All 8 unit tests passing, validates correct bit patterns and round-trip conversions
- Foundation ready for VM integration in next subtask (18.2)

Implementation reduces value size from ~32 bytes (WeaveType enum) to 8 bytes (u64), enabling significant memory and cache performance improvements.
</info added on 2025-07-28T20:34:41.223Z>

## 2. Replace WeaveType with NanBoxedValue in VM Core Structures [done]
### Dependencies: 18.1
### Description: Refactor VM stack, locals, and upvalues to use NanBoxedValue instead of WeaveType enum, updating all data structures and access patterns
### Details:
Replace WeaveType with NanBoxedValue in critical VM structures: Update VM stack from Vec<WeaveType> to Vec<NanBoxedValue>, modify CallFrame locals to use NanBoxedValue, update WeaveUpvalue to store NanBoxedValue. Implement stack manipulation methods (push, pop, peek) to work with NanBoxedValue directly. Update garbage collection roots to properly trace through NaN-boxed pointers. Ensure memory layout optimization for cache efficiency. Add migration helpers to convert existing WeaveType values during transition phase.
<info added on 2025-07-28T20:52:02.794Z>
COMPLETED: Successfully replaced WeaveType with NanBoxedValue in VM core structures:

## Major Changes Implemented:
1. **Updated VM struct fields**:
   - stack: Vec<WeaveType> → Vec<NanBoxedValue>
   - globals: HashMap<String, WeaveType> → HashMap<String, NanBoxedValue>
   - last_value: WeaveType → NanBoxedValue
   - VMResult: Result<WeaveType, VMError> → Result<NanBoxedValue, VMError>

2. **Updated stack manipulation methods**:
   - _push(), _pop(), _peek() now work with NanBoxedValue internally
   - Added _push_weave_type() helper for transition
   - Updated get_stack_var(), set_stack_var(), clone_stack_var()

3. **Updated all VM opcodes**:
   - CONSTANT, GetLocal, SetLocal, GetGlobal, SetGlobal, GetUpvalue, SetUpvalue
   - ADD, SUB, MUL, DIV arithmetic operations
   - GREATER, LESS, EQUAL comparison operations
   - TRUE, FALSE, NOT logical operations
   - CALL, RETURN function operations
   - PRINT output operation

4. **Added conversion helpers**:
   - weave_type_to_nan_boxed() for transition from WeaveType
   - nan_boxed_to_weave_type() for compatibility
   - Updated native function calls to convert args

5. **Implemented Display trait** for NanBoxedValue for REPL output

## Testing Results:
✅ Code compiles successfully with only warnings
✅ Basic arithmetic verified: '5 + 3' → '8' in REPL
✅ All VM operations successfully converted to NanBoxedValue

## Performance Impact:
- Reduced value size from ~32 bytes (WeaveType enum) to 8 bytes (u64)
- Eliminated Vec<WeaveType> cloning overhead on stack operations
- Enabled Copy semantics for stack values (NanBoxedValue is Copy)
- Foundation ready for direct NaN-boxed arithmetic operations in next subtask

The VM now uses NaN-boxing internally while maintaining WeaveType compatibility through conversion helpers. Ready for next subtask to implement direct NaN-boxed operations.
</info added on 2025-07-28T20:52:02.794Z>

## 3. Update VM Opcodes for NaN-boxed Operations [in-progress]
### Dependencies: 18.2
### Description: Modify all VM opcodes to operate on NaN-boxed values directly, implementing fast paths for arithmetic operations
### Details:
Update all opcodes in vm.rs to work with NanBoxedValue: Implement fast-path arithmetic operations (Add, Subtract, Multiply, Divide) that check if both operands are numbers using inline bit tests and operate on raw f64 values without unpacking. Update comparison operations to handle NaN-boxed values correctly. Modify CONSTANT, GetLocal, SetLocal, GetGlobal, SetGlobal to work with NanBoxedValue. Update function call and return mechanisms to handle NaN-boxed values. Implement branchless arithmetic using conditional moves where possible. Add specialized opcodes for common patterns like number-to-number operations.

## 4. Implement Pointer Management and Garbage Collection Updates [pending]
### Dependencies: 18.3
### Description: Update pointer storage, retrieval, and garbage collection to work correctly with NaN-boxed pointer values
### Details:
Implement pointer encoding/decoding for heap-allocated types (strings, functions, closures): Design pointer tagging scheme using available bits in 48-bit payload space, ensure pointer values maintain proper alignment for platform requirements. Update garbage collector to extract and trace pointers from NaN-boxed values, implement fast pointer extraction using bit masking. Update string interning, function allocation, and closure creation to return NaN-boxed pointers. Add safety checks in debug builds to verify pointer validity. Implement efficient batch pointer extraction for GC marking phase.

## 5. Performance Optimization and Validation [pending]
### Dependencies: 18.4
### Description: Implement critical performance optimizations and validate 4x memory traffic reduction goal with comprehensive benchmarks
### Details:
Implement performance-critical optimizations: Add inline assembly or intrinsics for ultra-fast type checking (test high 16 bits), optimize hot paths in arithmetic operations using SIMD where applicable. Implement bulk stack operations using memcpy for value moves. Add compiler hints for branch prediction in type dispatch. Create comprehensive benchmark suite measuring: memory bandwidth reduction (target 4x improvement), arithmetic operation throughput, type checking overhead, overall VM execution speed on real workloads (fibonacci, mandelbrot, closure-heavy code). Profile and optimize cache usage patterns. Document performance characteristics and tuning guidelines.

## 6. Complete WeaveType Elimination [pending]
### Dependencies: 18.3
### Description: Completely eliminate WeaveType throughout the codebase, replacing with NanBoxedValue to eliminate all type conversion overhead
### Details:
Replace WeaveType completely with NanBoxedValue in:
1. Chunk constants: Vec<WeaveType> → Vec<NanBoxedValue>
2. Native function interface: fn(&[WeaveType]) → fn(&[NanBoxedValue])
3. All operator implementations (Add, Sub, Mul, Display) - move from WeaveType to NanBoxedValue
4. Remove ALL conversion functions: weave_type_to_nan_boxed() and nan_boxed_to_weave_type()
5. Update compiler to emit NanBoxedValue constants directly

This eliminates the dual-type system overhead that causes 6-8 conversions per function call, achieving the target 20-50x performance improvement.

## 7. Fix Function Call Performance Scaling Issues [pending]
### Dependencies: 18.6
### Description: Address O(n²) scaling behavior and optimize function call hot paths to achieve 10,000+ calls/second
### Details:
Current Performance Issue: 
- 2500 iterations = 7 seconds (357 calls/second)
- 5000 iterations = 28 seconds (178 calls/second) 
- Shows O(n²) scaling instead of linear O(n)

Key Optimizations:
1. Profile and fix open_upvalues data structure (suspected O(n²) behavior)
2. Optimize stack growth patterns to reduce Vec reallocations
3. Streamline Op::Call and Op::RETURN protocols after WeaveType elimination
4. Remove bounds checking in release builds for hot paths
5. Implement CallFrame pooling optimizations
6. Pre-allocate larger stack chunks

Target: Linear O(n) scaling with 10,000+ function calls/second performance

