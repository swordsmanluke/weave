# Weave Interpreter: Fix Recursive Function Call Issues

## Problem Statement

The Weave interpreter currently has multiple critical bugs preventing recursive function calls from working correctly. When attempting to execute recursive functions like factorial, the interpreter fails with errors like "Cannot multiply '<fn factorial(1)>' and '1.00'", indicating that function calls within binary expressions are returning function objects instead of executing the functions.

## Root Cause Analysis

Through extensive debugging and trace analysis, we've identified three interconnected issues:

1. **Parser Precedence Bug**: The precedence parser fails to generate `Op::Call` instructions for function calls within binary expressions (e.g., `n * factorial(n-1)`). The parser treats the function identifier as a variable lookup (`GetGlobal`) instead of recognizing the following parentheses as triggering a function call.

2. **VM Call Mechanism Issue**: The `call()` method in the VM was returning `Ok(self._peek())` without proper execution flow, though this may be working correctly in some contexts.

3. **Stack Indexing Bug**: Local variable access has off-by-one errors causing index out of bounds panics when functions have multiple call frames. The slot calculation `frame.slot + relative_slot` produces invalid stack indices.

## Success Criteria

1. **Recursive Functions Work**: `factorial(5)` should correctly compute and return `120.00`
2. **Binary Expressions with Function Calls Work**: `2 * add(3)` should return `8.00` (not `12.00`)
3. **No Stack Panics**: Function calls should not cause index out of bounds errors
4. **All Existing Tests Pass**: No regressions in basic functionality
5. **Debug Traces Show Correct Bytecode**: `factorial(n-1)` should generate `Op::Call` instructions

## Technical Requirements

### Parser/Compiler Fixes
- Fix precedence parsing to properly handle function calls in binary expressions
- Ensure `LeftParen` infix rule triggers `fn_call` method correctly
- Verify `Op::Call` bytecode generation for recursive calls
- Debug and fix any issues in `parse_precedence` method

### VM Execution Fixes  
- Fix stack slot calculation for local variables across call frames
- Ensure call frame setup works correctly for nested function calls
- Fix any issues in `Op::GetLocal` stack indexing
- Verify call frame slot offsets are calculated correctly

### Testing Requirements
- Create comprehensive test suite for recursive functions
- Test various binary expression + function call combinations
- Test deeply nested function calls
- Test edge cases like mutual recursion

## Implementation Approach

1. **Fix Parser Precedence First**: Address the core issue where `Op::Call` isn't generated
2. **Fix Stack Indexing**: Resolve the immediate crash from bad stack access
3. **Comprehensive Testing**: Verify all function call patterns work
4. **Performance Verification**: Ensure fixes don't impact performance

## Test Cases

### Basic Recursive Function
```weave
fn factorial(n) {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}
puts factorial(5)  # Should output 120.00
```

### Binary Expression with Function Call
```weave
fn add(x) { x + 1 }
puts 2 * add(3)    # Should output 8.00
```

### Nested Function Calls
```weave
fn fibonacci(n) {
    if n <= 1 {
        n
    } else {
        fibonacci(n-1) + fibonacci(n-2)
    }
}
puts fibonacci(6)  # Should output 8.00
```

### Multiple Call Frames
```weave
fn outer(x) {
    fn inner(y) {
        y * 2
    }
    inner(x) + 1
}
puts outer(5)      # Should output 11.00
```

## Constraints

- Maintain backward compatibility with existing Weave syntax
- Preserve performance characteristics of the interpreter
- Follow existing code patterns and architecture
- Ensure all changes are thoroughly tested before integration