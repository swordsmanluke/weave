# Logging System for Weaver Compiler/VM - Product Requirements Document

## Overview
Implement a comprehensive logging system for the Weaver language interpreter to replace scattered print statements with a structured, configurable logging solution that supports file output, console output control, and severity-based filtering.

## Problem Statement
Currently, the Weaver codebase uses print statements throughout the compiler and VM for debugging and diagnostic purposes. This approach is:
- Difficult to filter or manage
- Distracting during normal operation
- Not suitable for production use
- Lacks severity levels and context
- Cannot be easily redirected or controlled

## Users & Stakeholders
- **Primary Users**: Developers working on the Weaver interpreter
  - Need detailed logging for debugging compiler issues
  - Need to track VM execution flow during development
  - Need performance profiling information
  - Want logs enabled by default during development (will be disabled by default in future releases)

## User Stories

### Story 1: Basic Logging with Severity Levels
**As a** Weaver developer
**I want** to log messages with different severity levels (DEBUG, INFO, WARN, ERROR)
**So that** I can categorize and filter log output based on importance

**Acceptance Criteria:**
- Given a log statement with severity DEBUG, when logging is configured for INFO or higher, then the message is not output
- Given a log statement with severity ERROR, when any logging level is active, then the message is always output
- Given multiple log statements of different severities, when filtered by level, then only appropriate messages appear

### Story 2: Structured Log Output with Context
**As a** Weaver developer  
**I want** to include structured context data with my log messages
**So that** I can capture relevant debugging information like thread IDs, variable values, etc.

**Acceptance Criteria:**
- Given a log call with named parameters like `log.info("message", {thread_id: 123})`, when output as text, then format as `<timestamp> - file.rs:132 - thread_id: 123 - "message"`
- Given a log call with multiple context values, when output as text, then all values appear before the message
- Given a log call with context, when output as JSON, then context values appear as top-level keys

### Story 3: File Output by Default
**As a** Weaver developer
**I want** logs to be written to a file by default
**So that** I can review execution history without cluttering the console

**Acceptance Criteria:**
- Given no explicit configuration, when the application runs, then logs are written to a default log file
- Given a log file exists, when new logs are written, then they are appended (not overwritten)
- Given the log file path, when specified via CLI or config, then logs go to that location

### Story 4: Command Line Control
**As a** Weaver developer
**I want** command line switches to control logging behavior
**So that** I can adjust logging without changing code

**Acceptance Criteria:**
- Given a --log-level flag, when set to WARN, then only WARN and ERROR messages appear
- Given a --log-console flag, when present, then logs also output to console
- Given a --log-file flag with path, when specified, then logs write to that file
- Given no logging flags, when running, then logs write to default file location only

## Technical Requirements

### Log File Management
- Default log location: `./.weaver/logs/` directory (created if doesn't exist)
- Log rotation: 
  - Rotate when file reaches 5MB
  - Keep last 10 log files
  - Naming scheme: `weaver.log` (current), `weaver.log.1` through `weaver.log.10` (historical)

### Log Format
- Timestamp format: ISO 8601 (e.g., `2024-01-15T10:30:45.123Z`)
- Text format: `<timestamp> - <file>:<line> - <tags> - "<message>"`
- JSON format option for structured logging
- Support for arbitrary metadata tags/context values

### Severity Levels
- DEBUG - Detailed debugging information
- INFO - General informational messages  
- WARN - Warning conditions
- ERROR - Error conditions

### API Design
- Use existing Rust logging crates (evaluate `tracing` for its tagging/span features vs `log` + `env_logger`)
- Must support structured metadata/tags on log entries
- Simple macro-based API for developers: `log_debug!`, `log_info!`, `log_warn!`, `log_error!`
- Support for context values: `log_info!("message", thread_id = 123, module = "parser")`

### Command Line Interface
- `--log-level <LEVEL>` - Set minimum log level (DEBUG|INFO|WARN|ERROR), default: INFO
- `--log-console` - Also output logs to console (in addition to file)
- `--log-file <PATH>` - Override default log file location
- `--log-format <FORMAT>` - Choose output format (text|json)

### Configuration Defaults
- Default log level: INFO (when no --log-level specified)
- Single global log level for entire application (no per-module filtering)
- Console output uses same format as file output (no special formatting/colors)

## Implementation Considerations

### Initialization
- Initialize logging in main function as early as possible
- Same logging configuration for both REPL and file execution modes
- Default configuration should work without any setup

### Migration Strategy
- Piecemeal replacement of existing print statements
- Priority on quick completion of migration
- Maintain functionality during transition

### Performance
- DEBUG level logs remain in release builds for production debugging
- No TRACE level (only DEBUG, INFO, WARN, ERROR)
- Accept reasonable performance overhead for better debugging capability

### Error Handling
- If log directory cannot be created: crash with error message
- If disk space runs out: crash with error message
- Logging system failures should fail fast rather than fail silently

### Areas for Contextual Logging
- Compiler phases (scanning, parsing, code generation)
- VM execution (instruction execution, stack operations)
- Memory management (allocations, garbage collection)
- Function calls and returns
- Error handling and recovery

## Success Metrics
- All print statements in the codebase have been replaced with appropriate log calls
- Developers can effectively debug issues using the logging output
- Log files are manageable in size due to rotation
- No significant performance degradation in normal operation